package controller

import (
	"context"
	"fmt"

	"github.com/spotahome/kooper/controller"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	networkingv1beta1 "k8s.io/api/networking/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/selection"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/tools/cache"

	bilrostlabels "github.com/slok/bilrost/internal/kubernetes/labels"
)

// RetrieverKubernetesRepository is the repository used by the retriever.
type RetrieverKubernetesRepository interface {
	ListIngresses(ctx context.Context, ns string, options metav1.ListOptions) (*networkingv1beta1.IngressList, error)
	WatchIngresses(ctx context.Context, ns string, options metav1.ListOptions) (watch.Interface, error)
	ListSecrets(ctx context.Context, ns string, options metav1.ListOptions) (*corev1.SecretList, error)
	WatchSecrets(ctx context.Context, ns string, options metav1.ListOptions) (watch.Interface, error)
	ListDeployments(ctx context.Context, ns string, options metav1.ListOptions) (*appsv1.DeploymentList, error)
	WatchDeployments(ctx context.Context, ns string, options metav1.ListOptions) (watch.Interface, error)
	ListServices(ctx context.Context, ns string, options metav1.ListOptions) (*corev1.ServiceList, error)
	WatchServices(ctx context.Context, ns string, options metav1.ListOptions) (watch.Interface, error)
}

// NewRetriever returns the retriever for the controller.
// The retriever base is the ingress but the controller generates more resource
// that we need to listen on it's changes.
func NewRetriever(ns string, kuberepo RetrieverKubernetesRepository) (controller.Retriever, error) {
	// Create the selector for generated resources.
	genResSelector, err := getGeneratedResourceSelector()
	if err != nil {
		return nil, fmt.Errorf("could not generate the selector for controller generated resources: %w", err)
	}
	genResSelectorStr := genResSelector.String()

	return controller.NewMultiRetriever(
		// Main retriever (Ingress).
		controller.MustRetrieverFromListerWatcher(&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return kuberepo.ListIngresses(context.TODO(), ns, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return kuberepo.WatchIngresses(context.TODO(), ns, options)
			},
		}),

		// Generated resources (Secrets) by:
		// - Dex auth backend implementation.
		// - Oauth2proxy proxy implementation.
		controller.MustRetrieverFromListerWatcher(&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				options.LabelSelector = genResSelectorStr
				return kuberepo.ListSecrets(context.TODO(), ns, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				options.LabelSelector = genResSelectorStr
				return kuberepo.WatchSecrets(context.TODO(), ns, options)
			},
		}),

		// Generated resources (Services) by:
		// - Oauth2proxy proxy implementation.
		controller.MustRetrieverFromListerWatcher(&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				options.LabelSelector = genResSelectorStr
				return kuberepo.ListServices(context.TODO(), ns, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				options.LabelSelector = genResSelectorStr
				return kuberepo.WatchServices(context.TODO(), ns, options)
			},
		}),
	)
}

// getGeneratedResourceSelector returns a selector that is valid to select only
// the resources generated by bilrost (the generated resources must add the
// convenition label, check `internal/kubernetes/labels` package).
func getGeneratedResourceSelector() (labels.Selector, error) {
	// Create a requirement that checks if the Bilrost generated resource convention label exists.
	req, err := labels.NewRequirement(bilrostlabels.LabelKeySource, selection.Exists, []string{})
	if err != nil {
		return nil, err
	}

	sl := labels.NewSelector().Add(*req)
	return sl, nil
}
